# [백준] 1389 - 케빈 베이컨의 6단계 법칙
> Silver I

## 문제
케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다.

오늘은 Baekjoon Online Judge의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 찾으려고 한다. 케빈 베이컨 수는 모든 사람과 케빈 베이컨 게임을 했을 때, 나오는 단계의 합이다.

예를 들어, BOJ의 유저가 5명이고, 1과 3, 1과 4, 2와 3, 3과 4, 4와 5가 친구인 경우를 생각해보자.

1은 2까지 3을 통해 2단계 만에, 3까지 1단계, 4까지 1단계, 5까지 4를 통해서 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+1+2 = 6이다.

2는 1까지 3을 통해서 2단계 만에, 3까지 1단계 만에, 4까지 3을 통해서 2단계 만에, 5까지 3과 4를 통해서 3단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+2+3 = 8이다.

3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 통해 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 1+1+1+2 = 5이다.

4는 1까지 1단계, 2까지 3을 통해 2단계, 3까지 1단계, 5까지 1단계 만에 알 수 있다. 4의 케빈 베이컨의 수는 1+2+1+1 = 5가 된다.

마지막으로 5는 1까지 4를 통해 2단계, 2까지 4와 3을 통해 3단계, 3까지 4를 통해 2단계, 4까지 1단계 만에 알 수 있다. 5의 케빈 베이컨의 수는 2+3+2+1 = 8이다.

5명의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람은 3과 4이다.

BOJ 유저의 수와 친구 관계가 입력으로 주어졌을 때, 케빈 베이컨의 수가 가장 작은 사람을 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 유저의 수 N (2 ≤ N ≤ 100)과 친구 관계의 수 M (1 ≤ M ≤ 5,000)이 주어진다. 둘째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이루어져 있으며, A와 B가 친구라는 뜻이다. A와 B가 친구이면, B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복되어 들어올 수도 있으며, 친구가 한 명도 없는 사람은 없다. 또, 모든 사람은 친구 관계로 연결되어져 있다. 사람의 번호는 1부터 N까지이며, 두 사람이 같은 번호를 갖는 경우는 없다.

## 출력
첫째 줄에 BOJ의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 경우에는 번호가 가장 작은 사람을 출력한다.


## 풀이
그래프의 최단거리를 구하는 문제로 모든 노드끼리의 최단거리를 구하여야 하므로, ***플로이드-워샬(Floyd-Warshall)*** 알고리즘을 이용하여 해결하였다.
(너비 우선 탐색(BFS)으로도 해결할 수 있는 문제이다.)

```C
int **graph;
graph = (int**)malloc(sizeof(int*)*(n+1));
for (int i = 0; i < n+1; i++)
    graph[i] = (int*)malloc(sizeof(int)*(n+1));
    //(n+1)*(n+1) 인접행렬 그래프 생성
```

N -> 노드의 수, M -> 간선의 수이며 모든 간선의 가중치는 1로 생각하여 인접행렬로 양방향 그래프를 만들었다.

```C
for (int i = 1; i < n+1; i++){
    for (int j = 1; j < n+1; j++)
        graph[i][j] = INF;
    graph[i][i] = 0;
    graph[0][i] = 0;
}

for (int i = 0; i < m; i++) {
    int a, b;
    scanf("%d %d", &a, &b);
    graph[a][b] = graph[b][a] = 1;
} // 간선의 가중치가 모두 1인 가중치 그래프
```

그래프를 초기화 한다. 0번 요소는 추후에 케빈 베이컨 수를 연산하기 위해 0으로 초기화 해주었다.

```C
//Floyd-Warshall
for (int node = 1; node < n+1; node++){
    for (int i = 1; i < n+1; i++){
        for (int j = 1; j < n+1; j++){
            graph[i][j] = min(graph[i][j], graph[i][node] + graph[node][j]);
            if (node == n && graph[i][j] < INF)
                graph[0][i] += graph[i][j];
        }        
    }
}
```

플로이드-워샬 알고리즘의 핵심은 **graph[i][j] = min(graph[i][j], graph[i][node] + graph[node][j]);** 이다. 이 연산을 모든 노드끼리 반복하여 최단 거리를 구한다.

> 예를들어 1번 노드와 5번 노드의 최단 거리를 구한다고 할 때, 1 -> 5가 빠른지, 1 -> n -> 5가 빠른지 구하는 과정이다.

모든 연산이 끝난 후, '케빈 베이컨 수'를 구해 가장 그 수가 작은 번호를 출력하면 된다.