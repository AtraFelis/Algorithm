# [백준] 2178 - 미로 탐색
> Silver 2

## 문제
N×M크기의 배열로 표현되는 미로가 있다.

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

## 입력
첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

## 출력
첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

## 풀이

대표적인 너비 우선 탐색(BFS) 문제이다. C에는 Queue가 구현되어 있지 않기에, 배열을 이용해 queue처럼 동작하게끔 만들어 해결했다.

```C
map = (int**)malloc(sizeof(int*)*(n+2));
for (int i = 0; i < n+2; i++)
    map[i] = (int*)malloc(sizeof(int)*(m+2));
```

(n+2) * (m+2) 크기의 이차원 배열로 미로를 만들었다.

이유는 BFS에서 값을 탐색하는 과정에서, 맵 밖으로 벗어나는 것을 막기 위해서와 좌표 처리할 때 헷갈리지 않기 위해서다.

> if문으로 해도 되지만, 은근히 귀찮아서 이 방법을 사용했다.

```
00000000
01011110
01010100
01010110
01110110
00000000
```

미로에 외벽을 치는 느낌으로 탐색하지 않게 막았다.

### 너비우선 탐색 BFS

```C
int (*queue)[2] = (int (*)[2])malloc(n * m * sizeof(int[2]));
// 최악의 경우에도 n*m 개 이상의 좌표가 queue에 들어갈 일은 없으므로, n*m의 크기로 배열 동적할당.
queue[0][0] = 1; queue[0][1] = 1; 
int front = 0, rear = 1;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, -1, 1};

while(front != rear){
    int x = queue[front][0], y = queue[front++][1];

    for (int i = 0; i < 4; i++){
        if(map[x + dx[i]][y+dy[i]] != 0)
        {                   
            if(map[x + dx[i]][y+dy[i]] == 1){
                queue[rear][0] = x + dx[i];
                queue[rear++][1] = y+dy[i];
            } // 방문하지 않은 곳이면 queue에 추가

            if(map[x][y] < map[x + dx[i]][y+dy[i]] || map[x + dx[i]][y+dy[i]] == 1)
                map[x + dx[i]][y+dy[i]] = map[x][y] + 1;
        }
    }
}
```

1. 시작 위치 (1,1)을 큐에 넣는다.
2. 큐에서 좌표를 꺼내, 그 좌표를 기준으로 동서남북을 확인한다.

    1. 0이면 무시하고, 1이면 그 좌표를 큐에 넣는다.
    2. 방문하지 않았거나 (미로에 적힌 수가 1이거나), 현재 좌표에 입력된 수보다 값이 작으면 map[x][y] + 1 로 값을 업데이트 한다.

3. 이 과정을 큐가 빌 때까지 반복한다.
4. map[n][m]에 있는 값이 최단거리가 된다.