
# [백준] 11279 최대 힙
>Siver II

## 문제

널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.

1. 배열에 자연수 x를 넣는다.
2. 배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.

프로그램은 처음에 비어있는 배열에서 시작하게 된다.

## 입력

첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.

## 출력

입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.



## 풀이


문제에도 적혀있다 싶이, 최대 힙을 구현하는 문제로  C언어의 경우에는 Priroty Queue가 구현되어 있지 않기에 직접 구현해야 한다.

1차원 배열을 이용하여 구현하였다.

***

### 삽입 연산

1. 완전 이진 트리의 마지막 노드에 삽입.
2. 부모 노드와 비교하여, 부모 노드 < 자식 노드(방금 추가한 요소) 라면 교환.
3. 최대 힙의 성질에 만족할 때까지 반복.


```C
void push(max_heap *h, int value) {
    int i = ++h->size;

    while( (i!=1) && value > h->arr[i/2] ){
        h->arr[i] = h->arr[i/2];
        i /= 2;
    }

    h->arr[i] = value;
}
```

배열로 힙을 구현할 때, 배열의 0번째 요소를 무시하고 1부터 넣는 것이 구현이 쉽다.

- *왼쪽 자식 노드 = 부모 노드 * 2*
- *오른쪽 자식 노드 = 부모 노드 * 2 + 1*

이기 때문에, 별 다른 예외 처리 없이 쉽게 연산이 가능하기 때문이다.

***

### 삭제 연산

1. 루트 노드 삭제 및 return
2. 마지막 노드의 요소를 루트 노드로 옮긴다.
3. 왼쪽 자식 노드, 오른쪽 자식 노드 중 더 큰 값을 구한 후, 비교하여 교환한다.
4. 최대 힙의 성질에 만족할 때까지 반복


```C
int pop(max_heap *h) {
    int value = h->arr[1];
    h->arr[1] = h->arr[h->size--];
    
    int parent = 1, child = 2;

    while(true){1. 
        if(child > h->size)
            break;
        if((h->arr[child] < h->arr[child+1]) && child < h->size)
        // child가 size와 크기가 같으면 오른쪽 자식 노드가 존재하지 않는 것이므로 무시해야 함.
            child++;
        
        if(h->arr[parent] >= h->arr[child])
            break;

        int tmp = h->arr[child];
        h->arr[child] = h->arr[parent];
        h->arr[parent] = tmp;

        parent = child;
        child *= 2;
    }
    return value;
}
```

3번 과정에서 **트리의 마지막 레벨에서 오른쪽 자식 노드가 존재하지 않을 때**를 고려하여야 한다.

1차원 배열을 이용하여 구현할 때, *size* 변수를 이용하였는데, 삭제를 진행하더라도 배열 내부적으로 *arr[h->size+1]* 에 값을 가지고 있으므로 예외 처리를 해주지 않으면, 오른쪽 자식 노드가 있는 것처럼 연산을 진행하게 된다.

이 점을 고려하여 마지막 요소가 '왼쪽 자식 노드'일 때 '오른쪽 자식 노드'는 무시하도록 ***child < h->size***조건을 넣어주어야 한다.