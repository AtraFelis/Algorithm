# [백준] 1629 - 곱셈

> SILVER I

## 문제

자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.

### 출력

첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.

## 풀이

나머지 연산(modular) 분배법칙을 활용하는 문제이다. 여기서 중요한 것은 주어지는 값이, 32bit 정수의 최대값까지라는 것이다. 즉, 오버플로우가 나타나는 경우를 고려해야 한다.

### 나머지 연산애서 분배법칙

$
(A * B)\ \%\ p = ((A\ \%\ p) * (B\ \%\ p))\ \%\ p
$

이렇게 나머지 연산으로 분배법칙을 수행할 수 있다. 중요한 것은 분배한 이후 한 번 더 나머지 연산을 수행해야 한다는 점이다.

제곱 또한 곱셈의 연속이므로, 이 공식을 이용하여 문제를 해결하면 된다.

### 오버플로우

이 문제에서 주어지는 최댓값은, $2^{31} - 1$이다.

이때 연산 과정에서 발생할 수 있는 최댓값은 (분배법칙을 풀이에 적용한다고 했을 때) $A =2^{31}-2$, $C^{31}-1$일 때이다. 이렇게 값이 주어지면, $A^2$을 했을 때 int형으로 할 수 있는 최댓값을 벗어나게 된다.

따라서, 64bit 정수형인 `long long`을 사용해야 한다.

$$2^{63} - 1 > (2^{31}-1)^2 = 2^{62} -2 \times 2^{31} + 1$$

이므로 `long long`으로 충분히 커버 가능하다.

```C
a %= c;
long long answer = 1;    
for (b; b > 1; b /= 2){
    if(b % 2 == 1)
        answer = (answer * a) % c;
    a = (a * a) % c;
}
answer = (answer * a) % c;
```

지수 부분을 2배씩 줄이면서 나머지 연산을 수행한다. (그냥 하면 시간 초과) 여기서 지수가 홀수라면, 미리 저장을 해두고 나중에 연산을 진행하면 된다.

### 전체 코드

```C
#include <stdio.h>

int main() {

    long long a, b, c;
    scanf("%lld %lld %lld", &a, &b, &c);

    a %= c;
    long long answer = 1;    
    for (b; b > 1; b /= 2){
        if(b % 2 == 1)
            answer = (answer * a) % c;
        a = (a * a) % c;
    }    
    answer = (answer * a) % c;
    printf("%lld", answer);

    return 0;    
}
```