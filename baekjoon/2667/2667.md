# [백준] 6054 - 카잉 달력 
> Silver I

## 문제
최근에 ICPC 탐사대는 남아메리카의 잉카 제국이 놀라운 문명을 지닌 카잉 제국을 토대로 하여 세워졌다는 사실을 발견했다. 카잉 제국의 백성들은 특이한 달력을 사용한 것으로 알려져 있다. 그들은 M과 N보다 작거나 같은 두 개의 자연수 x, y를 가지고 각 년도를 <x:y>와 같은 형식으로 표현하였다. 그들은 이 세상의 시초에 해당하는 첫 번째 해를 <1:1>로 표현하고, 두 번째 해를 <2:2>로 표현하였다. <x:y>의 다음 해를 표현한 것을 <x':y'>이라고 하자. 만일 x < M 이면 x' = x + 1이고, 그렇지 않으면 x' = 1이다. 같은 방식으로 만일 y < N이면 y' = y + 1이고, 그렇지 않으면 y' = 1이다. <M:N>은 그들 달력의 마지막 해로서, 이 해에 세상의 종말이 도래한다는 예언이 전해 온다.

예를 들어, M = 10 이고 N = 12라고 하자. 첫 번째 해는 <1:1>로 표현되고, 11번째 해는 <1:11>로 표현된다. <3:1>은 13번째 해를 나타내고, <10:12>는 마지막인 60번째 해를 나타낸다.

네 개의 정수 M, N, x와 y가 주어질 때, <M:N>이 카잉 달력의 마지막 해라고 하면 <x:y>는 몇 번째 해를 나타내는지 구하는 프로그램을 작성하라.

## 입력
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 한 줄로 구성된다. 각 줄에는 네 개의 정수 M, N, x와 y가 주어진다. (1 ≤ M, N ≤ 40,000, 1 ≤ x ≤ M, 1 ≤ y ≤ N) 여기서 <M:N>은 카잉 달력의 마지막 해를 나타낸다.

## 출력
출력은 표준 출력을 사용한다. 각 테스트 데이터에 대해, 정수 k를 한 줄에 출력한다. 여기서 k는 <x:y>가 k번째 해를 나타내는 것을 의미한다. 만일 <x:y>에 의해 표현되는 해가 없다면, 즉, <x:y>가 유효하지 않은 표현이면, -1을 출력한다.

## 풀이
모든 경우의 수를 확인하여 답을 구하는 브르투보스 알고리즘 문제이다.

#### 첫 번째 시도

첫 시도에는, M, N에 대하여 나올 수 있는 모든 경우의 수를 구해, <x:y>라는 해가 나오는지 확인하는 식으로 반복문을 돌렸고 성공했다.

```C
int tmp_x=1, tmp_y=1;
int answer = 1;
while(1){
    if(tmp_x == x && tmp_y == y) {
        printf("%d\n", answer);
        break;
    } else if(tmp_x==m && tmp_y==n) {
        printf("-1\n");
        break;
    }

    tmp_x = tmp_x < m ? tmp_x+1 : 1;
    tmp_y = tmp_y < n ? tmp_y+1 : 1;
    answer++;
}
```

하지만 백준에서는 '시간초과'가 나타났기 때문에, 조금 더 효율적인 방법을 고민해보았다.

> 시간 복잡도가 O(m*n)이 되어 문제의 시간 제한인 1초를 넘어가기 때문으로 보인다.

#### 두 번째 시도

어차피 x, y에 와 같은 값이 나올 수 있는지 구하는 문제이므로, x와 y 중 하나를 **고정**하면 비교 횟수가 확연히 줄겠다고 판단했다. m > n 이면 x를, m < n면 y를 고정하면 더 빠르겠으나, 그렇게까지 하지 않아도 시간은 충분할 것 같아 x를 고정하는 것으로 했다.

 ```C
int tmp = x%n;
if(tmp == 0)
    tmp = n;

int answer = x;
int check = tmp;

while(answer <= m*n) {
    if(tmp == y){
        printf("%d\n", answer);
        break;
    }

    tmp = (tmp + m) % n;
    if(tmp == 0)
        tmp = n;

    answer += m;
    
    if(tmp == check) {
        //첫 번째 경우로 돌아온다면 존재하지 않는다는 뜻.
        printf("-1\n");
        break;
    }
}    
```

> 이유는 모르겠으나, vscode에서 while(1)로 무한반복을 돌리면 컴파일이 느려져서, *answer <= m\*n*으로 조건을 주었다.


알고리즘

1. 입력된 x를 고정하여 생각한다. 초기 시작 연도가 <x:x>가 되는 것.
2. y값 증가 공식은, tmp = (tmp + n) % m이다. 계산값이 0 이면, tmp = m이 된다. 
2. tmp가 초기값과 같아지면, 해가 존재하지 않는 것이므로 -1 출력.
3. tmp가 y와 같은 값이 나타나면, 해가 존재하는 것이므로 answer 출력.
4. 위 2, 3 과정을 반복.

주의해야할 점은, 반복문 전에 tmp 값을 할당할 때, x > n 인 경우가 있을 수 있으므로 나머지 연산을 해주어야한다.