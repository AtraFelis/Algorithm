# [백준] 11687 - 팩토리얼 0의 개수

> SILVER I

![image](https://github.com/AtraFelis/AtraFelis.github.io/assets/107051266/1b3b71a8-309c-4770-a312-b10f066ccac9)

## 문제

가장 끝의 0의 개수가 M개인 N! 중에서 가장 작은 N을 찾는 프로그램을 작성하시오.

### 입력

첫째 줄에 M (1 ≤ M ≤ 100,000,000)이 주어진다.

### 출력

가장 끝의 0의 개수가 M개인 N! 중에서 가장 작은 N을 출력한다. 그러한 N이 없는 경우에는 -1을 출력한다.

## 풀이

수학적 사고력을 조금 요구하는 이진 탐색 문제로, 0의 개수가 어떤 규칙에 의해서 정해지는지 알아내는 것이 이 문제를 해결하는 핵심이 된다.

### 0의 개수

문제에 주어진 `예제 입력`들을 확인하면 팩토리얼 연산 시, 어떤 때에 0의 개수가 증가하는지 쉽게 알아낼 수 있다.

- 팩토리얼의 해에 포함된 0의 개수

    ```    
    m = 1 → n = 5
    m = 2 → n = 10
    m = 3 → n = 15
    m = 4 → n = 20
    ```


    팩토리얼 연산시 5가 추가될 때마다, 0의 개수가 증가함을 알 수 있다. 정확히는 10 ( 2 * 5 )의 개수가 증가할 때이지만, 팩토리얼 연산에서 2의 개수가 5의 개수보다 많은 것은 자명하므로 등장하는 5의 개수만 체크하면 된다.

    ```
    m = 5 → n = -1
    m = 6 → n = 25
    ```

    예제를 보면서 직관적으로 생각하면, 25!의 0의 개수는 5개가 되어야 할 것 같지만, 25는 5 * 5로 5를 두 번 포함하고 있다. 따라서 25!의 0의 개수는 6개가 된다.

    `따라서, 0의 개수는 식에 포함된 5의 개수와 같다.`

<br>

- 팩토리얼 연산에서 0의 개수를 구하는 방법

    만약 27! 이라면,

    1. 27 / 5 = 5 // 포함된 5의 개수
    2. 27 / 25 = 27 / 5 / 5 = 1 // 포함된 25의 개수

    이므로, 5 + 1 = 6개의 0을 가진다.


<br>

### 이진 탐색

주어지는 m, 그러니까 0의 개수의 최댓값은 10억이다.

5의 배수일 때만 n의 최솟값이 되니 5씩 늘리면서 반복문을 돌린다고 하더라도 주어진 0.5초라는 시간 내에는 해결하지 못할 것이다.

그렇기에 이진 탐색을 활용하여 탐색 횟수를 줄인다. 시간복잡도는 $O({n \over 5 })$ 에서 $O(log{n})$ 으로 줄어들게 된다.



### 전체 코드

```C
#include <stdio.h>

int main() {

    int m;
    scanf("%d", &m);

    //binary search
    int min, mid, max;

    min = 5 / 5;
    max = 400000015 / 5;
    // '400000015' : '0' 이 100,000,000이 나오는 값. 즉, 이 문제의 최댓값.
    mid = (min + max) / 2;
    // 탐색을 편하게 하기 위해서 미리 5로 나눈 값을 기준으로 이분 탐색 시작함.

    int zero_cnt = 0;
    while (zero_cnt != -1)
    {

        zero_cnt = mid;
        int tmp = mid;
        for ( ; tmp >= 5; tmp /= 5)
            zero_cnt += tmp / 5;

        if(zero_cnt > m)
        {
            max = mid - 1;
            mid = (min + max) / 2;
        }
        else if ( zero_cnt < m )
        {
            min = mid + 1;
            mid = (min + max) / 2;
        }
        else { // zero_cnt == m
            mid *= 5;
            break;
        } // 해가 존재

        if(min > max){
            mid = -1;
            break;
        } // 해가 존재하지 않음
    }

    printf("%d", mid);
    
    return 0;
}
```